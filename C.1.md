## 실전 사례 1: 전자상거래 주문 처리 시스템 (Order Management)

**배경**

* 고객은 상품을 장바구니에 담고 주문을 생성합니다.
* 관리자는 주문 상태를 확인하거나 배송을 진행합니다.

**적용 방식**

* **Command 모델**에서는 `PlaceOrder`, `CancelOrder`, `ShipOrder` 같은 쓰기 동작만 처리.

  * 이때 복잡한 비즈니스 로직 (재고 확인, 결제 승인, 쿠폰 검증 등)이 수행됨.
* **Query 모델**에서는 `GetOrderStatus`, `ListCustomerOrders` 등 읽기만 수행.

  * NoSQL 또는 읽기 최적화된 데이터베이스 (예: Redis, Elasticsearch)를 사용하여 고속 응답 제공.

**효과**

* 주문 생성 및 상태 조회가 서로 영향을 주지 않음.
* 조회 성능을 위해 별도 뷰 모델을 최적화 가능.
* 읽기 요청이 폭주해도 쓰기 성능에는 영향이 없음.

## 실전 사례 2: 금융 서비스의 계좌 관리 시스템

**배경**

* 사용자 계좌에 대한 입금/출금 트랜잭션과 계좌 내역 조회를 제공해야 함.
* 트랜잭션 정합성과 조회 성능이 모두 중요함.

**적용 방식**

* **Command 모델**에서는 `DepositMoney`, `WithdrawMoney` 명령이 도메인 모델을 통해 실행되며 이벤트 저장소에 기록 (Event Sourcing).
* **Query 모델**에서는 이벤트로부터 생성된 Projection을 바탕으로 `GetBalance`, `ListTransactions` 같은 질의 수행.

**효과**

* 잦은 거래 요청 처리 시에도 빠른 조회 성능 유지.
* 감사 및 이력 관리가 용이 (Event 저장소를 통해 추적 가능).
* CQRS + Event Sourcing의 조합으로 회복력, 추적성 강화.

## 실전 사례 3: SaaS 기반 프로젝트 관리 툴 (예: Trello, Jira)

**배경**

* 사용자는 작업 항목 생성/이동/편집 등 다양한 쓰기 작업을 수행하며,
* 프로젝트 보드 조회는 다양한 필터와 조건으로 매우 빈번하게 발생.

**적용 방식**

* **Command 모델**은 복잡한 권한, 상태 전이 검사를 포함해 쓰기 로직 전담.
* **Query 모델**은 사용자에게 맞춤형 보드 뷰, 필터된 작업 목록을 고속으로 제공.

**효과**

* 사용자 수 증가에도 읽기 성능 유지.
* 특정 사용자 맞춤 쿼리에 최적화된 Projection 제공 가능.
* 백엔드 쓰기 복잡도와 프론트엔드 UX를 분리하여 독립적 개선 가능.

### 요약

| 요소    | Command 모델                    | Query 모델                   |
| ----- | ----------------------------- | -------------------------- |
| 목적    | 상태 변경                         | 데이터 조회                     |
| 특성    | 복잡한 도메인 로직, 트랜잭션 포함           | 읽기 최적화 (캐싱, Projection 등)  |
| 기술 조합 | Event Sourcing, DDD와 자주 함께 사용 | NoSQL, Read Replica와 잘 어울림 |
| 장점    | 확장성과 복잡도 분리, 성능 최적화           | 읽기 모델 독립적 최적화 가능           |
