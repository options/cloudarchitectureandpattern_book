## 4.2 서킷 브레이커(Circuit Breaker) 패턴

현대의 클라우드 기반 분산 시스템은 다수의 마이크로서비스로 구성되며, 이들 간의 통신은 종종 HTTP나 gRPC 등의 네트워크 프로토콜을 통해 이루어집니다. 이러한 환경에서는 일부 컴포넌트의 실패가 전체 시스템의 장애로 이어지는 경우가 빈번하게 발생하며, 이는 복원력(Resiliency)과 안정성을 저해하는 주요 요인이 됩니다. 서킷 브레이커(Circuit Breaker) 패턴은 이러한 문제를 완화하기 위한 디자인 패턴으로, 장애 전파를 차단하고 시스템 전반의 신뢰성을 높이는 데 기여합니다.

### 서킷 브레이커 패턴의 개요

서킷 브레이커 패턴은 전기공학에서 차용된 개념입니다. 회로 차단기(circuit breaker)가 과전류가 흐를 때 회로를 차단하여 기기의 손상을 방지하는 것처럼, 소프트웨어의 서킷 브레이커는 서비스 간 호출이 반복적으로 실패할 경우 해당 호출을 일정 시간 차단함으로써 시스템의 리소스를 낭비하지 않고 복구 기회를 부여합니다. 한 마이크로서비스가 과도한 요청이나 장애 상태에 빠졌을 때, 서킷 브레이커는 해당 서비스에 대한 추가 요청을 중단시켜 요청자의 리소스와 응답 시간을 보호하고, 전체 시스템의 트래픽 흐름을 안정적으로 유지할 수 있도록 돕습니다.

### 동작 방식과 상태 전이 모델

서킷 브레이커는 일반적으로 다음 세 가지 상태 중 하나를 유지하며, 상태 간 전이를 통해 동작합니다.

1. Closed 상태:
   평상시 상태이며, 모든 요청이 정상적으로 전달됩니다. 일정 시간 동안 실패율이 임계값을 초과하면 Open 상태로 전이됩니다. 이때 실패율은 일반적으로 특정 시간 또는 요청 수 내에서 실패 응답(예: HTTP 5xx)의 비율로 정의됩니다.

2. Open 상태:
   요청이 차단되며, 호출자는 즉시 실패 응답(예: HTTP 503 Service Unavailable)을 수신합니다. 이 상태는 일정 시간 동안 유지되며, 이를 cool-down 기간이라 부릅니다.

3. Half-Open 상태:
   cool-down 기간이 지난 후 일부 제한된 수의 요청만을 대상으로 테스트가 수행되며, 이 요청이 성공하면 다시 Closed 상태로 전이됩니다. 반대로 실패가 지속되면 다시 Open 상태로 돌아갑니다.

이러한 상태 전이 모델을 통해 서킷 브레이커는 장애 전파를 방지하고, 장애 복구 가능성을 판단하며, 안정적인 시스템 운영을 유지할 수 있습니다.

### 서킷 브레이커 구현 시 고려사항

서킷 브레이커를 효과적으로 구현하기 위해서는 다음과 같은 주요 설정값과 정책을 신중히 설계해야 합니다.

- 실패 기준(Failure Threshold): 서킷을 Open 상태로 전이할 때 사용하는 기준입니다. 예를 들어, 실패율이 50% 이상일 경우 Open으로 전환하게 할 수 있습니다.

- half-open 시의 테스트 수: Half-Open 상태에서 몇 개의 요청으로 시스템의 회복 여부를 판단할지 결정합니다.

- Cool-down 주기(Time Window): Open 상태가 유지되는 최소 기간입니다. 이 값은 시스템의 회복 시간 특성을 고려하여 설정해야 합니다.

- 요청 및 실패 추적 방법: Sliding window 또는 bucket 기반의 통계 수집을 통해 실패율을 산정합니다.

- 예외 기준: 모든 에러가 실패로 간주되는 것은 아니며, 타임아웃이나 특정 HTTP 상태 코드만을 실패로 간주할 수 있습니다.

### 실제 구현 기술 및 라이브러리

마이크로서비스 아키텍처에서는 서킷 브레이커 기능을 구현할 수 있는 다양한 라이브러리 및 프레임워크가 제공됩니다. 분산 서비스 간 통합에 일반적으로 사용되는 도구를 통해 이를 손쉽게 적용할 수 있습니다.

- Netflix Hystrix:
  Java 기반의 가장 널리 알려진 서킷 브레이커 라이브러리 중 하나입니다. 실패 격리, 타임아웃, 리트라이 등의 기능뿐 아니라 모니터링 대시보드도 제공합니다. 다만 현재는 유지보수가 중단되었으며, 다른 솔루션으로의 전환이 권장되는 상황입니다.

- resilience4j:
  Hystrix의 대체제로, 모듈화된 설계를 통해 서킷 브레이커, 레이트 리미터, 타임아웃 기능 등을 분리하여 제공합니다. Java 8 이상에 최적화되어 있으며, Spring Boot와의 통합도 용이합니다.

- Istio의 DestinationRule과 VirtualService:
  서비스 메시(Service Mesh) 환경에서는 서킷 브레이커 기능이 프록시 레벨에서 구현됩니다. Istio는 Envoy 프록시를 활용하여 서킷 브레이커 설정을 선언적으로 적용할 수 있으며, 서비스 측의 코드 수정 없이 신뢰성을 향상시킬 수 있습니다.

- Spring Cloud Circuit Breaker:
  Spring Boot 기반의 마이크로서비스에서는 Spring Cloud Circuit Breaker 추상화를 통해 다양한 서킷 브레이커 구현체(Hystrix, resilience4j, Sentinel 등)를 라우팅 형식으로 적용할 수 있습니다.

- OpenFeign + resilience4j 연동:
  마이크로서비스 간의 선언적 REST 클라이언트로서 OpenFeign을 사용하는 경우, resilience4j를 쉽게 통합할 수 있으며, 호출 실패에 따른 graceful degradation을 간편하게 처리할 수 있습니다.

### 적용 사례와 실전 시나리오

1. 마이크로서비스 간 종속성 완화:
   예를 들어, 주문 서비스를 구성할 때 재고 서비스가 과부하되거나 지연되는 상황을 가정하겠습니다. 이때 서킷 브레이커를 재고 서비스 앞단에 배치하면, 재고 서비스 장애가 발생했을 때 주문 서비스는 빠르게 fallback 로직을 수행하거나 "제한적 주문 보류" 상태를 리턴할 수 있습니다. 이를 통해 전체 시스템이 장애 상태에서 벗어나 안정적으로 동작할 수 있습니다.

2. Fallback과 함께 사용하는 경우:
   서킷 브레이커는 종종 Fallback 패턴과 함께 사용됩니다. 호출 실패 또는 서킷이 열린 상태일 경우 대체 경로 또는 캐시된 데이터를 반환하게 함으로써 사용자 경험의 급격한 저하를 방지할 수 있습니다. 예를 들어, 사용자 프로필 이미지를 로드하는 API가 실패할 경우 디폴트 이미지를 응답하게 하는 방식입니다.

3. 실시간 모니터링과 알림:
   서킷 브레이커 구성 요소의 상태(Open, Closed, Half-Open)는 즉각적인 운영 지표로 활용이 가능합니다. Prometheus와 Grafana를 활용하거나 resilience4j의 모듈을 통합하여 실시간으로 서비스 오류율과 서킷 상태를 시각화하고, 이상 징후 발견 시 알람을 받을 수 있습니다.

### 서킷 브레이커 패턴의 한계

서킷 브레이커가 무조건 올바른 선택인 것은 아닙니다. 종속 서비스가 일시적인 오류 상태가 아니라 구조적으로 처리 속도가 느린 경우에는 서킷 브레이커가 효과를 보지 못할 수 있으며, Half-Open 상태에서의 요청이 수용기능을 넘어서면서 다시 장애를 유발할 위험이 있습니다. 또한 fallback 로직의 품질이 낮을 경우 사용자의 기대를 충족시키지 못해 오히려 혼란을 야기할 수 있습니다. 따라서 서킷 브레이커는 서비스 특성과 SLA 요구사항, 클라이언트의 수용 범위 등을 고려하여 적용되어야 합니다.

### 결론

서킷 브레이커 패턴은 시스템이 외부 또는 하위 컴포넌트의 장애로부터 완전히 무너지지 않도록 보호하는 중요한 메커니즘입니다. 특히 클라우드 네이티브 환경에서는 마이크로서비스의 독립적인 장애 격리가 필수적이며, 서킷 브레이커를 통해 서비스 복원력과 사용자의 경험을 최소한으로 제한된 수준으로 보장할 수 있게 됩니다. 이 패턴은 적절한 도구 선택과 정책 설계, 모니터링 전략을 함께 고려하여 구현되어야 하며, 잘 설계된 Fallback 전략과 함께 사용할 때 더욱 높은 효과를 거둘 수 있습니다.