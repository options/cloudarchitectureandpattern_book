## 4.5 이벤트 소싱(Event Sourcing) 패턴

모던 클라우드 아키텍처에서 상태 변화의 흐름을 명확하게 추적하고, 데이터 일관성을 확보하며 애플리케이션의 확장성 및 감사 가능성을 높이기 위한 접근법으로 이벤트 소싱(Event Sourcing) 패턴이 자주 사용됩니다. 이 절에서는 이벤트 소싱의 정의와 구조, 구현 시 고려사항, 그리고 실제 적용 사례를 중심으로 상세히 설명드리겠습니다.

### 이벤트 소싱 패턴의 개념 이해

이벤트 소싱은 엔터티나 애그리것(Aggregate)의 상태를 데이터베이스에 단순히 덮어쓰는 전통적인 방식 대신, 상태의 모든 변경 사항을 별도의 이벤트로 기록하는 저장 전략입니다. 즉, 시스템의 현재 상태는 "최종 상태 스냅샷"이 아닌 "이벤트의 집합"으로부터 파생됩니다.

예를 들어, 은행 계좌의 현재 잔고를 단일 데이터 필드로 저장하는 대신, 그 잔고를 구성하는 입금/출금 이벤트들을 모두 저장해두고 이를 재생함으로써 최종 상태를 구성합니다. 이러한 방식은 전통적인 CRUD(Create, Read, Update, Delete) 모델과 본질적으로 다른 접근을 취합니다.

이벤트 소싱의 본질은 다음과 같은 원칙을 따릅니다:

- 상태 변경은 모두 도메인 이벤트로 표현된다.
- 저장소에는 상태 자체가 아닌 도메인 이벤트의 시퀀스가 저장된다.
- 시스템 상태는 이벤트의 재생(Event Replay)을 통해 재구성된다.

이러한 방식을 채택함으로써 변화의 원인을 투명하게 기록할 수 있으며, 변경 사항에 대한 감사 및 롤백, 이벤트 기반 통합 등의 다양한 장점이 발생합니다.

### 이벤트 소싱의 구조 및 구성 요소

이벤트 소싱 시스템은 일반적으로 다음과 같은 구성 요소로 구성됩니다:

1. **도메인 이벤트(Domain Event)**  
   상태 변경의 의미를 갖는 불변(Immutable) 객체입니다. 예: `AccountCredited(amount=1000)` 또는 `OrderShipped(timestamp=...)` 등. 이벤트는 반드시 시간 순으로 정렬되며, 어떤 액션이 언제 어떤 대상에 대해 발생했는지를 서술합니다.

2. **이벤트 저장소(Event Store)**  
   관계형 데이터베이스 또는 전용 이벤트 스토어(Kafka, EventStoreDB 등)를 사용하여 이벤트를 순차적으로 append-only 방식으로 저장합니다. 일반적인 CRUD 저장소와 달리 update/delete 연산은 사용하지 않습니다.

3. **커맨드 핸들러(Command Handler)**  
   이벤트를 직접 생성하지 않고, 비즈니스 행위인 커맨드(Command)를 기반으로 도메인 로직을 실행한 뒤 이벤트를 생성합니다. 커맨드는 보통 “의도(intention)”를 나타냅니다. 예: `IncreaseAccountBalance`.

4. **도메인 모델 및 애그리것(Aggregate)**  
   이벤트 시퀀스를 기반으로 현재 상태를 생성하거나 복원하는 데 사용되는 클래스입니다. 모든 도메인 규칙은 이 모델 내에 정의되어야 하며, 커맨드를 수용하고 유효성을 검사한 후 해당하는 이벤트를 발생시킵니다.

5. **이벤트 핸들러(Event Handler) 및 뷰 모델(View/Read Model)**  
   이벤트를 수신하여 읽기 모델 또는 외부 시스템으로 전달하거나, CQRS 패턴과 결합되어 조회 성능을 높이기 위한 View 모델 생성을 담당합니다.

### 이벤트 소싱 구현 시 고려사항

이벤트 소싱은 많은 이점을 제공하지만, 구현 시 다음과 같은 중요한 고려사항이 있습니다:

- **이벤트의 변경 불가능성(Immutability)**  
  이벤트는 단순 로그가 아니라 시스템의 진실(Truth Source)이므로 추후 변경이 불가능해야 합니다. 잘못된 이벤트가 저장되었다면 수정하는 것이 아니라 새 이벤트로 그것을 무효화하는 방식(Compensating Event)으로 처리해야 합니다.

- **이벤트 버전 관리(Event Versioning)**  
  도메인 모델이 진화함에 따라 이벤트의 구조나 의미가 변경될 수 있습니다. 이 경우 이벤트 버전(version)을 명확히 관리하고, 구버전 이벤트를 역직렬화하여 현재 모델에 재적용 가능하도록 어댑터 또는 마이그레이션 전략이 필요합니다.

- **이벤트 저장소의 확장성 및 성능**  
  이벤트 로그가 끊임없이 축적됨에 따라 성능 저하나 저장 한계에 직면할 수 있습니다. 이런 경우 스냅샷(snapshot) 전략을 활용하여 일정 수의 이벤트 재생을 생략하고 중간 상태를 저장소에 별도로 보관하기도 합니다.

- **일관성과 트랜잭션 경계**  
  이벤트 소싱은 주로 CQRS(Command Query Responsibility Segregation)와 결합되는 경우가 많으며, 이 경우 명령 처리와 조회가 물리적으로 분리됩니다. 이로 인해 eventual consistency에 대한 이해와 수용이 요구됩니다.

- **운영 및 디버깅 난이도**  
  이벤트 스트림 자체는 사람이 읽기에 복잡한 경우가 많으므로, 도구 지원, 시각화, 감시(Auditing), 테스트 전략이 필요합니다.

### 클라우드 환경에서의 이벤트 소싱 적용 사례

클라우드 네이티브 애플리케이션, 특히 마이크로서비스 아키텍처에서 이벤트 소싱은 데이터 간의 비동기 통합을 위한 기반 기술로 각광받고 있습니다. 다음은 대표적인 적용 시나리오들입니다:

1. **은행 및 금융 시스템**
   예금, 출금, 이체 등의 상태 변경은 모두 법적 근거가 필요하며 감사 추적이 중요합니다. 이벤트 소싱을 적용하면 모든 트랜잭션을 투명하게 기록할 수 있으며, 특정 시점으로의 롤백이나 재분석이 가능합니다.

2. **이커머스 플랫폼**
   주문의 생성, 승인, 결제, 배송 등 상태의 흐름을 이벤트화함으로써 멱등성 처리, 실패 내성 패턴, 추후의 데이터 분석이 용이해지며 결제 실패나 배송 지연 시 복구 로직 구현에 유리합니다.

3. **IoT 기반 시스템**
   센서 이벤트가 연속적으로 발생하고 각각의 사건에 유의미한 의미를 부여해야 할 때, 이벤트 스트림을 중심으로 처리 흐름과 현재 상태를 구성할 수 있습니다.

4. **분산된 마이크로서비스 간 통합**
   Order, Inventory, Payment 등의 도메인이 별도의 서비스로 나뉘어 있을 때, 이벤트 브로커(Kafka, Amazon EventBridge 등)를 통해 이벤트를 공유하고 의존성 없이 상태를 동기화할 수 있습니다.

5. **블록체인과 유사한 신뢰 기반 처리**
   변경 불가능한 이벤트 로그는 블록체인 시스템의 원리와도 유사하게 동작하며, 투명성과 감사 추적을 극대화해야 하는 시스템에 적합한 특성을 가집니다.

### CQRS와의 긴밀한 연계

이벤트 소싱과 가장 궁합이 좋은 아키텍처 중 하나는 CQRS 입니다. 이벤트 소싱은 시스템의 Write 모델에서 이벤트를 발생시켜 저장하고, 이를 기반으로 별도의 Read 모델을 구성하며, 각 모델은 서로 다른 저장소를 사용할 수 있습니다.

이때 이벤트는 Write 모델이 발생시키며, Read 모델(Projection)은 비동기적으로 이벤트를 구독하여 업데이트됩니다. 일반적으로 Read 모델은 빠른 조회를 위해 denormalized된 형태로 구성되며, NoSQL 스토리지를 사용하는 경우가 많습니다.

### 이벤트 소싱을 성공적으로 적용하기 위한 실무 전략

이벤트 소싱은 강력한 패턴이지만 모든 시스템에 적합하지는 않습니다. 이를 성공적으로 도입하기 위해 다음과 같은 전략을 권장드립니다:

- **핵심 도메인 위주 선택 적용**: 이벤트 소싱은 구현 복잡도를 증가시키므로, 트랜잭션 무결성과 감사가 필요한 핵심 도메인에 한정하여 적용하는 것이 현실적입니다.

- **성숙된 도메인 모델링**: 이벤트 기반 설계는 도메인 모델 구조가 명확할수록 성공 가능성이 높습니다. DDD(Domain-Driven Design)의 철학에 따라 애그리것, 커맨드, 이벤트를 구조화하는 것이 바람직합니다.

- **적절한 도구 및 미들웨어 선택**: 이벤트 스토어로서 Apache Kafka, EventStoreDB, Amazon Kinesis, DynamoDB Streams 등 다양한 옵션이 존재하므로 시스템 요구사항에 따라 적절한 도구를 선택해야 하며, 분산 트레이싱이나 장애 복구 기능도 함께 고려하셔야 합니다.

- **운영 도구화 및 모니터링 체계 수립**: 이벤트 흐름을 실시간으로 추적하고 어떤 이벤트가 누락되었거나 실패하였는지 알 수 있도록 로그 및 모니터링 체계를 사전에 준비해야 합니다. 이는 복잡한 시스템일수록 더욱 중요한 요소가 됩니다.

### 마무리하며

이벤트 소싱은 상태 변경을 기록하고 추적하려는 모든 소프트웨어 시스템에서 강력한 패러다임 전환을 가능하게 합니다. 비록 구현의 복잡도와 러닝 커브로 인해 무비판적인 도입은 지양해야 하지만, 클라우드 네이티브 환경에서는 분산 트랜잭션의 대안으로, 그리고 비동기 메시징 기반 협조를 가능하게 하는 설계 방식으로 점차 그 입지를 넓혀가고 있습니다.

향후 장에서는 CQRS, 이벤트 브로커, 분산 ID 전략 등과 연계하여 이벤트 소싱의 확장적 활용 방안을 더 구체적으로 다루도록 하겠습니다.