## 4.7 메시지 기반 설계(Message-based design)

현대의 클라우드 네이티브 아키텍처에서 메시징은 단지 통신 수단을 넘어, 시스템 아키텍처의 핵심 구성 요소 중 하나로 간주됩니다. 메시지 기반 설계(Message-based design)는 느슨하게 결합된 구성 요소들 사이에서 안정적인 비동기 통신을 가능하게 하며, 시스템의 확장성, 복원력, 유연성을 크게 향상시킵니다. 이 절에서는 메시지 기반 설계의 개념, 주요 구성 요소, 장단점, 주요 패턴과 실무 적용 사례를 차례로 설명 드리겠습니다.

### 메시지 기반 설계란 무엇인가

메시지 기반 설계는 서로 다른 서비스 또는 구성 요소가 직접 호출하지 않고, 메시지를 통해 비동기적으로 상호작용하는 아키텍처 스타일입니다. 전통적인 요청-응답 방식의 동기 통신과는 달리, 메시지를 생성한 컴포넌트(발행자, producer)는 메시지를 보내고 난 뒤 수신자의 응답을 기다리지 않으며, 수신자(소비자, consumer)는 전달된 메시지를 자체적으로 처리합니다. 이 방식은 비교적 단순한 개념처럼 보이지만, 점점 더 분산되고 복잡해지는 현대 시스템 환경에서 매우 중요한 역할을 수행합니다.

### 메시지 기반 설계의 핵심 구성 요소

메시지 기반 아키텍처를 구성하기 위해선 다음과 같은 핵심 요소들이 필요합니다.

#### 메시지(Message)

메시지는 시스템 간에 교환되는 데이터 단위입니다. 일반적으로 JSON, Avro, Protocol Buffers 등으로 직렬화되며, 메시지 구조에는 본문(payload) 뿐만 아니라, 헤더(header), 메타데이터, unique ID, 타임스탬프, 리트라이 카운트 등의 정보를 포함할 수 있습니다.

#### 메시지 브로커(Message Broker)

메시지 브로커는 발행자와 소비자 사이에서 메시지를 중개하고, 일시적으로 저장하며, 전달을 보장하는 시스템입니다. 대표적인 메시지 브로커에는 RabbitMQ, Apache Kafka, Amazon SQS, Google Pub/Sub, NATS 등이 있습니다. 브로커는 메시지 단일 소비(single consumer), 다중 소비(multicast 또는 fan-out), 주제 기반(pub/sub) 등의 다양한 라우팅 전략을 지원합니다.

#### 발행자(Producer)와 소비자(Consumer)

발행자는 메시지를 생성하고 브로커에 전달하는 역할을 하며, 소비자는 브로커로부터 메시지를 읽어서 처리합니다. 이들 간에는 직접적인 의존 관계가 없기 때문에 느슨한 결합(loose coupling)을 유지할 수 있으며, 이로 인해 시스템의 확장성과 변경 용이성이 크게 향상됩니다.

#### 큐와 토픽(Queue & Topic)

메시지를 전달하기 위한 논리적인 채널입니다. 큐(queue)는 한 번에 하나의 소비자만 메시지를 가져가는 방식의 지점 간(point-to-point) 모델을 구현하며, 토픽(topic)은 여러 소비자가 동일한 메시지를 받아볼 수 있는 publish/subscribe 모델을 구성할 때 사용됩니다.

### 메시지 기반 설계의 이점

메시지 기반 아키텍처를 채택하면 다음과 같은 주요 장점을 얻을 수 있습니다.

- 서비스 간 결합도 감소로 인한 변경 용이성 증가
- 비동기 처리를 통한 응답 속도 향상 및 사용자의 체감 성능 개선
- 버스트 트래픽 대응력 향상 및 자연스러운 확장성 확보
- 장애 격리와 복원력 증가: 한 서비스의 실패가 다른 서비스로 전파되지 않음
- 다양한 소비자가 하나의 메시지를 처리하게 하여 새로운 기능 확장 용이

예를 들어, 주문 처리 시스템에서 사용자가 쇼핑몰에서 결제를 완료하면, 결제 완료 시점에 주문 완료 메시지를 Kafka를 통해 발행하고, 이를 수신하는 여러 소비자(예: 재고 차감, 배송 요청, 포인트 적립, 알림 서비스 등)가 각자의 방식대로 독립적으로 처리하게 할 수 있습니다.

### 메시지 기반 설계의 단점과 고려사항

그러나 메시지 기반 설계를 도입할 경우 반드시 함께 고려해야 할 과제들도 존재합니다.

- 시스템 전반에 걸친 트랜잭션 일관성 유지가 어려움 (분산 트랜잭션의 복잡성 증가)
- 순서 보장 문제(ordering): 메시지 순서가 보장되지 않는 경우 상태 비일관성이 초래될 수 있음
- 중복 소비, 메시지 유실, 처리 실패 등에 대한 보완 설계 필요
- 디버깅 및 트레이싱 복잡성 증가 (분산 환경의 로그 및 모니터링 체계 필요)
- 생산자와 소비자의 재처리 전략 및 리트라이 정책에 대한 명확한 정의 필요

이러한 이유로 메시지 기반 아키텍처를 도입함에 있어서는 시스템 전체의 운영 및 장애 대응 전략을 포함한 면밀한 아키텍처 설계가 요구됩니다.

### 메시지 기반에서의 주요 패턴

실무에서는 다음과 같은 메시징 패턴이 빈번히 활용됩니다.

#### Pub/Sub (Publish/Subscribe)

발행자가 특정 토픽에 메시지를 게시하면, 해당 토픽을 구독하고 있는 모든 소비자들이 메시지를 수신합니다. 구독자는 선택적으로 토픽을 필터링할 수 있습니다. Google Pub/Sub, SNS(SNS + SQS), Kafka 등이 이 방식을 적극 지원합니다.

#### Point-to-Point (Queue 기반 모델)

메시지가 각각의 큐에 직접 전달되며, 각 메시지는 오직 한 명의 소비자에 의해 소비됩니다. 작업 대기열(job queue) 처리와 같은 정렬된 메시지 흐름이 필요한 시나리오에 적합합니다.

#### Dead Letter Queue (DLQ)

처리에 실패한 메시지를 분리하여 보관하는 별도의 큐입니다. 재처리 정책 설정, 실패 원인 분석 및 운영 로그 추적에 활용됩니다. 모든 미들웨어에서 DLQ 지원 기능이 제공되는 것은 아니므로 사전 검토가 필요합니다.

#### 이벤트 드리븐(Event-driven) 패턴

시스템의 동작 흐름이 이벤트(메시지) 발생에 의해 구동되도록 구성합니다. 마이크로서비스 환경에서 업무 도메인의 애그리거트 간 통신을 메시지 기반으로 구현함으로써 자연스럽게 헥사고날 아키텍처나 DDD 구현과 융합된 형태로 확장될 수 있습니다.

### 실전 적용 사례

AWS를 활용한 메시징 기반 설계 사례를 살펴보겠습니다. 마이크로서비스 구조 기반의 전자상거래 애플리케이션에서는 다음과 같은 설계를 적용할 수 있습니다.

1. 사용자가 상품을 구매하고 결제를 완료하면 "OrderPlaced" 이벤트가 Amazon SNS 토픽에 게시됩니다.
2. 이 토픽은 Amazon SQS 큐들과 연결돼 있으며 각각의 큐는 개별 소비자에 매핑됩니다 (예: 배송 처리 마이크로서비스, 포인트 적립 마이크로서비스, 마케팅 이메일 발송 마이크로서비스 등).
3. 각 마이크로서비스는 자체 큐에서 이벤트 메시지를 수신하고, 독립적으로 비즈니스 로직을 수행합니다.
4. 실패한 메시지는 Dead Letter Queue에 별도로 적재되어 운영자가 수동 분석하거나 자동 리커버리 프로세스에 활용할 수 있습니다.

이 아키텍처는 확장성이 뛰어나며, 주문 처리 흐름 하나에도 여러 서비스를 연계하면서도 서비스 각각의 독립성과 복원력을 확보할 수 있는 장점을 제공합니다.

### 클라우드 서비스의 메시징 도구 비교

| 서비스 | 브로커 유형 | 주요 특징 | 적합한 사용 시나리오 |
|--------|----------------|-------------|------------------|
| Amazon SQS | 큐 (P2P) | 완전 관리형, ACID 보장 X | 단순한 작업 처리, 대량 메시지 큐 |
| Amazon SNS | Pub/Sub | 푸시 기반 알림, 팬아웃 구조 | 이벤트 브로드캐스팅 |
| Apache Kafka | 스트리밍 + Pub/Sub | 고성능 로그 기반 스트리밍, 고도 설정 필요 | 실시간 분석, CEP, 이벤트 소싱 |
| RabbitMQ | 큐 + 라우팅 | AMQP 기반 메시징, 플러그인 풍부 | 다양한 라우팅 요구, 순서 관리 |
| Google Pub/Sub | Pub/Sub | 완전 관리형, 훌륭한 확장성 | 모바일 백엔드, 로깅 시스템 연계 |

이처럼 클라우드 환경에서는 다양한 메시징 플랫폼이 제공되며, 요구되는 내구성, 성능, 개발 편의성 등을 종합적으로 고려하여 선택하셔야 합니다.

### 메시지 기반 설계의 향후 전망

메시징은 단순한 통신 방식에서 벗어나, 데이터 기반 아키텍처, 이벤트 소싱, CQRS, 스트리밍 분석 등과 밀접하게 통합되며 클라우드 아키텍처의 핵심 요소로 자리잡고 있습니다. 특히 서버리스 환경에서는 메시지의 발행과 소비가 Lambda, EventBridge, Step Function 등의 서비스와 결합되어 더욱 강력한 흐름 제어를 가능하게 합니다.

향후에는 메시지를 통한 트랜잭션 보장, 처리 지연 최소화, 통합 트레이싱 및 추론형 메시지 플로우 관리 등에서 보다 정교한 도구와 운영 모델이 요구될 것이며, 이는 곧 메시지 기반 설계에 대한 이해와 경험이 클라우드 엔지니어의 핵심 역량으로 자리잡게 될 것임을 의미합니다.

결론적으로, 메시지 기반 아키텍처는 단지 상호 통신을 분리하는 메커니즘을 넘어서, 시스템의 생명력을 높이고 복잡성 속에서도 안정적 운용을 가능케 하는 중요한 설계 전략임을 이해하셔야 합니다. 실제 도입을 고려하실 때는 메시지 채널 설계, 리트라이 시나리오, 보안, 모니터링 체계까지 포함한 총체적인 접근이 필요합니다.