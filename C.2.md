## CQRS 패턴 실습 과제: “이벤트 관리 시스템 설계 및 구현”

### 시나리오

당신은 소규모 스타트업의 백엔드 개발자로 채용되었습니다. 회사는 세미나, 워크숍, 컨퍼런스 등의 **이벤트 등록 및 관리 웹 서비스**를 새롭게 개발하려고 합니다. 현재 MVP 단계로 기능은 단순하지만, 향후 사용자 수가 급증할 것을 대비해 **성능과 확장성**을 고려한 아키텍처가 요구됩니다.

기획팀은 다음과 같은 기능을 요구합니다:

### 요구 기능

**Command (쓰기)**

1. 이벤트 생성(CreateEvent)
2. 이벤트 수정(UpdateEvent)
3. 이벤트 삭제(DeleteEvent)
4. 참가자 등록(RegisterParticipant)

**Query (읽기)**

1. 특정 이벤트 상세 조회(GetEventDetails)
2. 전체 이벤트 목록 조회(ListUpcomingEvents)
3. 특정 참가자의 이벤트 등록 내역 조회(ListMyRegistrations)

### 과제 목표

CQRS 패턴을 활용하여 다음을 수행하세요.

#### Part 1: 설계

* **Command 모델**과 **Query 모델**을 분리한 아키텍처 다이어그램을 작성하시오.
* 데이터베이스 모델을 각각의 모델에 맞게 분리하여 설계하시오.
* 쓰기 모델은 **RDB (예: PostgreSQL)**, 읽기 모델은 **NoSQL (예: MongoDB)** 또는 캐시 기반 저장소로 설계하시오.
* 도메인 레벨에서 쓰기 모델에 대한 유효성 검사, 비즈니스 로직을 설계하시오.

#### Part 2: 구현

* Command API와 Query API를 별도로 구현하시오 (예: `/api/commands/*`, `/api/queries/*`).
* 이벤트 등록 시 참가자 수 제한, 중복 등록 방지 등의 비즈니스 로직을 포함하시오.
* Query 모델은 쓰기 이벤트에 따라 Projection을 업데이트하는 방식으로 구현하시오. (간단한 Message Queue 또는 cron job으로 시뮬레이션 가능)

#### Part 3: 테스트 및 시연

* 동시 사용자 100명 이상이 동시에 조회할 때와 등록할 때의 성능 차이를 테스트하시오.
* 읽기 요청이 증가할 때 쓰기 성능에 영향을 주지 않는 구조임을 시연하시오.

### 제출 항목

* 설계 문서 (PDF 또는 Markdown)
* 소스코드 (GitHub Repository 링크)
* REST API 명세서 (Swagger 또는 Postman 등)
* 테스트 결과 요약 보고서 (JMeter, k6 등 도구 활용 가능)
* 본인이 설계한 구조의 장단점에 대한 간단한 기술 소감 (1페이지 이내)

### 팁

* 읽기 모델을 위한 Projection은 이벤트가 생성되거나 참가자가 등록될 때만 갱신되므로 비동기 업데이트 전략을 사용해도 무방합니다.
* 실제 환경에서는 Kafka, RabbitMQ 등을 사용할 수 있지만, 학습 목적상 간단한 in-memory queue나 cron 기반 task로 대체해도 충분합니다.


## CQRS 패턴 실습 과제 ②: “소셜 피드 서비스 설계 및 구현”

### 시나리오

당신은 스타트업 SNS 플랫폼의 백엔드 팀원입니다. 사용자들이 글을 작성하고, 서로 팔로우하며, 실시간으로 피드를 확인할 수 있는 **소셜 피드 서비스**의 핵심 기능을 개발해야 합니다. 기획팀은 피드 조회 속도에 민감하며, 수천 명을 팔로우한 사용자가 빠르게 자신의 피드를 확인할 수 있어야 한다고 강조합니다.


### 요구 기능

**Command (쓰기)**

1. 사용자 계정 생성(CreateUser)
2. 글 작성(CreatePost)
3. 팔로우/언팔로우 사용자(FollowUser, UnfollowUser)

**Query (읽기)**

1. 특정 사용자의 글 목록 조회(GetUserPosts)
2. 로그인 사용자의 피드 조회(GetMyFeed)

### 과제 목표

CQRS 패턴을 적용하여 **쓰기 모델과 읽기 모델을 분리**하고, 실시간 피드 조회 성능을 최적화하는 구조를 설계하고 구현해보세요.

#### Part 1: 설계

* Command와 Query를 분리한 아키텍처를 설계하시오.
* 쓰기 모델에서는 RDB 기반의 정규화된 스키마를 사용하시오.
* 읽기 모델에서는 사용자 피드를 빠르게 제공할 수 있도록 **비정규화된 피드 Projection**을 생성하시오 (예: 사용자별 피드 캐시, MongoDB, Redis 등).
* 팔로우 관계 변경 시, 피드 Projection을 어떻게 유지할지 설계하시오 (Push model vs Pull model도 고려).

#### Part 2: 구현

* RESTful API 또는 GraphQL 기반으로 Command/Query API를 나누어 구현하시오.
* 읽기 모델은 **팔로우한 사용자의 최신 글**을 기준으로 정렬된 피드를 제공해야 합니다.
* 피드 갱신은 이벤트 기반 비동기 처리로 구현하되, 단순 큐 또는 폴링 로직으로 대체해도 무방합니다.

#### Part 3: 테스트 및 검증

* 팔로우 관계가 1000명 이상인 사용자에게도 피드 조회가 1초 이내에 응답되는지 테스트하시오.
* Command와 Query의 확장 가능성을 비교 설명하시오.
* 피드 구조를 바꾸지 않고, 조회 API만 수정하여 검색/필터 기능을 확장할 수 있는지 검토하시오.

### 제출 항목

* 전체 시스템 설계 문서 (CQRS 분리 구조 포함)
* 주요 API 명세서
* 코드 저장소 (GitHub 링크)
* 읽기 모델의 Projection 동작 흐름도
* 피드 업데이트 방식(Push vs Pull) 비교 보고서
* 테스트 결과 및 성능 측정 보고서

### 확장 과제 (선택)

* **좋아요/댓글 기능 추가** 시, CQRS 모델에 어떤 영향을 미치는지 설명하고 구현해 보세요.
* 실시간 피드를 위한 WebSocket 또는 Server-Sent Events(SSE) 기능을 추가해 보세요.

물론입니다. CQRS는 **엔터프라이즈 시스템**에서 더욱 강력한 효용을 발휘합니다. 특히 복잡한 비즈니스 로직과 많은 사용자가 동시에 시스템을 사용하는 환경에서는 **Command와 Query의 분리**를 통해 확장성과 유지 보수성을 확보할 수 있습니다. 다음은 **엔터프라이즈 환경에서 실습 가능한 시나리오 기반 과제**입니다.


## 🏢 CQRS 패턴 실습 과제 ③: "기업용 구매 승인 시스템(B2B Procurement Approval System)"

### 시나리오

당신은 중견 기업의 IT 부서에서 근무 중입니다. 이 기업은 전사적인 구매 요청, 승인, 예산 관리 기능을 갖춘 **사내 구매 관리 시스템**을 개발하려고 합니다. 조직은 계층 구조로 이루어져 있으며, 각 부서와 사용자에게 **권한 기반의 구매 요청 및 승인 프로세스**가 필요합니다.

**기존 시스템은 단일 DB 구조로 모든 로직을 처리했지만**, 실시간 승인 현황 조회가 느리고, 요청이 많아질수록 승인 처리 지연 문제가 발생하고 있어 CQRS 기반으로 구조를 재설계하려고 합니다.

### 요구 기능

**Command (쓰기)**

1. 구매 요청 생성(CreatePurchaseRequest)
2. 요청 수정 또는 취소(UpdateRequest, CancelRequest)
3. 구매 승인/반려(ApproveRequest, RejectRequest)
4. 결제 처리(MarkAsPaid)

**Query (읽기)**

1. 사용자의 요청 목록 조회(ListMyRequests)
2. 부서별 요청 현황 조회(ListDepartmentRequests)
3. 전체 예산 사용 현황 조회(GetBudgetSummary)
4. 특정 요청의 상세 이력 조회(GetRequestHistory)

### 과제 목표

CQRS 패턴을 적용하여 다음을 수행하세요.

#### Part 1: 시스템 설계

* 복잡한 승인 로직과 예산 체크 로직을 Command 모델에 명확히 분리하시오.
* Query 모델은 대시보드 또는 관리자 포털에서 사용될 수 있도록 **읽기 최적화 Projection**을 구성하시오.
* Command 모델은 RDB (예: MS SQL, PostgreSQL), Query 모델은 Document DB 또는 OLAP 데이터베이스를 사용할 수 있음.
* 승인 요청에 따른 이벤트 흐름 (ex: `RequestCreated → Approved → Paid`) 을 정의하시오.

#### Part 2: 구현

* REST API 또는 GraphQL로 Command/Query 인터페이스를 분리하여 구현하시오.
* 비동기 이벤트 처리 방식으로 읽기 모델 업데이트를 수행하시오. (ex: Kafka 대신 단순 Event Bus 또는 Task Queue로 대체 가능)
* Query 모델에서는 부서별 필터링, 시간대별 통계, 예산 범위 검색 등을 효율적으로 제공하도록 설계하시오.

#### Part 3: 테스트 및 분석

* 1만 건 이상의 요청이 있는 상황에서도 **실시간 필터링**과 **페이징 응답 속도**를 측정하시오.
* 동일한 기능을 단일 모델(Monolithic CRUD 방식)로 구현했을 때와 비교하여 성능 및 유지보수성 차이를 분석하시오.
* 권한에 따라 다른 데이터를 보여주는 Query 접근 제어 방식을 설계하시오 (예: 팀장 vs 일반 직원 vs 회계 관리자).

### 제출 항목

* 시스템 설계 문서 (CQRS 구조도 포함)
* DB 설계서 (쓰기 모델 vs 읽기 모델)
* API 명세서
* 읽기 모델 Projection 정의 및 처리 흐름
* 성능 테스트 결과 및 병목 구간 분석
* 사용자 권한별 Query 전략 정리

### 확장 과제 (선택)

* **이력 관리 기능**을 위해 Event Sourcing과 결합해 보세요. 모든 구매 요청의 상태 변경 내역을 저장하고 시점 복원 기능을 구현해 보세요.
* **감사 추적 로그 시스템**과 연계하여, 이벤트 발생 시 감사를 위한 로그 데이터 자동 생성 기능을 추가해 보세요.

### 학습 포인트 요약

| 구분      | 학습 내용                        |
| ------- | ---------------------------- |
| 구조 설계   | CQRS 아키텍처, 읽기/쓰기 모델 분리       |
| 도메인 로직  | 승인 절차, 예산 확인, 권한 기반 처리       |
| 데이터 모델링 | Projection 설계, 정규화 vs 비정규화   |
| 성능 분석   | 읽기 최적화 전략, 시스템 병목 탐색         |
| 확장성 고려  | Event Sourcing, 감사 로그, 보안 관리 |

## CQRS 패턴 실습 과제 ④: “기업용 신용카드 거래 처리 및 분석 시스템”

### 시나리오

당신은 대형 카드사의 내부 시스템을 개선하는 IT 프로젝트 팀에 배치되었습니다. 기존 시스템은 모든 트랜잭션과 고객 활동 데이터를 **동일한 DB에서 처리**하고 있어, 트랜잭션 발생량이 많은 시점(월말, 연휴 직후 등)에 **지연 현상과 일시적 마비**가 빈번히 발생하고 있습니다.

기획팀은 아래의 목표를 제시합니다:

* 수천 건의 거래가 동시에 처리되는 동안에도,
* 고객과 상담원이 **즉시 거래 내역을 확인**할 수 있어야 하며,
* **고객 맞춤형 리포트, 이상 거래 탐지**, 월별 통계 등도 빠르게 제공되어야 한다.

### 요구 기능

**Command (쓰기)**

1. 실시간 결제 승인 처리(AuthorizeTransaction)
2. 승인 취소 및 정정(UpdateTransaction)
3. 자동 이체 등록(RegisterAutoPayment)
4. 결제 실패 처리(MarkTransactionFailed)

**Query (읽기)**

1. 최근 거래 내역 조회(GetRecentTransactions)
2. 월별 소비 요약 조회(GetMonthlySpendingSummary)
3. 고객별 이상 거래 탐지 결과 조회(GetAnomalyAlerts)
4. 가맹점별 거래 집계(GetMerchantSummary)

### 과제 목표

CQRS 패턴을 적용하여, **거래 처리 로직과 조회 로직을 완전히 분리**한 시스템을 설계하고 구현하세요.

#### Part 1: 설계

* 실시간 거래 처리 로직(승인, 정정 등)을 Command 모델로 처리하고, 비즈니스 규칙(한도 초과, 분실 카드 여부 등)을 포함하시오.
* Query 모델은 **고속 조회와 통계 처리**를 위해 비정규화된 테이블 혹은 OLAP 구조로 설계하시오.
* Projection(읽기 모델)은 트랜잭션 이벤트를 기반으로 갱신되도록 설계하시오.
* 이상 거래 탐지는 이벤트 수신 후 비동기 분석 방식으로 처리할 수 있음.

#### Part 2: 구현

* 쓰기와 읽기 API를 별도로 구성하되, 내부적으로는 공통된 도메인 모델 구조를 유지하시오.
* Kafka 또는 Redis Stream 같은 메시지 큐 없이도 간단한 이벤트 브로커 또는 배치 처리 방식으로 구현 가능.
* 월별 요약, 가맹점 통계, 이상 거래 탐지 결과를 포함한 **다양한 Projection을 구성**하시오.

#### Part 3: 검증 및 보고

* 하루 10만 건 이상 거래 처리 시 Query 응답 속도를 측정하시오.
* 읽기 모델은 OLAP 또는 시계열 DB 기반으로도 구현 가능하며, 다른 Query 모델과의 차이점을 비교하시오.
* 동일한 데이터를 다르게 표현하기 위해 Projection을 재구성해보세요 (예: 날짜별, 가맹점별, 카드 상품별 등).

### 제출 항목

* 전체 CQRS 아키텍처 설계도
* 쓰기 모델과 읽기 모델의 DB 설계 비교
* API 명세서
* Projection 구성 및 갱신 흐름 설명
* 성능 측정 리포트
* 거래 이상 탐지 로직의 흐름도 및 적용 방식 설명

### 확장 과제 (선택)

* **Event Sourcing**을 기반으로 거래의 상태 변경 히스토리를 유지하고, 특정 시점 상태 복원 기능 구현해 보세요.
* **다중 지역 데이터 동기화**를 위한 CQRS + Replication 전략을 검토하고 간단한 프로토타입을 구현해 보세요.
* **비동기 이벤트 기반 보안 감사 로그 시스템**을 구현해 보세요 (예: 관리자 조회 기록, 승인 변경 등).

### 학습 포인트 요약

| 학습 항목   | 설명                              |
| ------- | ------------------------------- |
| 트랜잭션 처리 | 실시간 Command 모델 설계와 비즈니스 룰 적용    |
| 성능 최적화  | Query 모델 분리 및 다양한 Projection 전략 |
| 데이터 분석  | 고객별, 기간별, 가맹점별 통계 분리 설계         |
| 확장성     | 이벤트 기반 처리, 읽기 모델의 수평 확장성        |



