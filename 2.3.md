## 2.3 컨테이너와 Kubernetes 개요

클라우드 네이티브 애플리케이션의 핵심 구성 요소로 자리한 기술 중 하나가 바로 컨테이너(container)와 Kubernetes입니다. 이들은 가볍고 민첩한 소프트웨어 배포 방식과 마이크로서비스 아키텍처에 이상적으로 어울리는 도구로서, 현대적인 클라우드 네이티브 구축의 표준으로 자리잡았습니다. 특히 Kubernetes는 컨테이너 기반 애플리케이션 환경의 자동화된 운영, 확장, 복구 기능을 제공함으로써 대규모 분산 시스템의 복잡함을 극복할 수 있는 핵심 플랫폼으로 부상하였습니다.

이 절에서는 컨테이너의 정의와 원리, Kubernetes의 개념과 구조, 그리고 이들이 무슨 이유에서 클라우드 네이티브 환경에서 필수적인지에 대해 상세히 설명드리겠습니다.

### 컨테이너란 무엇인가

컨테이너는 애플리케이션 실행 환경을 코드와 의존성, 라이브러리 등을 포함한 단일 단위로 패키징하는 경량화된 가상화 기술입니다. 전통적인 가상 머신(Virtual Machine)이 하이퍼바이저를 통해 운영체제(OS) 단위의 격리를 제공하는 방식과는 달리, 컨테이너는 호스트 운영체제를 공유하는 방식으로 동작하지만, 프로세스와 파일 시스템은 완벽히 격리되어 있습니다.

#### 컨테이너의 주요 특징

1. 경량성: VM과 달리 전체 OS를 포함하지 않기 때문에 시작 속도가 빠르고 메모리 사용량이 적습니다.
2. 이식성: 동일한 컨테이너 이미지는 로컬 개발 환경, 온프레미스, 클라우드 환경 등 어디서든 일관되게 실행할 수 있습니다.
3. 일관된 실행 환경: 외부 환경의 영향을 받지 않고, 컨테이너 내부에 정의된 환경변수, 런타임 및 의존성으로 실행되므로 데브(Dev)와 프로드(Prod) 환경 사이의 차이를 줄일 수 있습니다.
4. 불변 인프라(Infrastructure as Immutable Artifacts): 컨테이너는 코드 변경 없이 재배포가 가능하며, 기존 컨테이너를 삭제하고 새로운 이미지로 교체함으로써 일관된 배포 프로세스를 유지할 수 있습니다.

#### Docker를 중심으로 한 컨테이너 생태계의 발전

Docker는 컨테이너 기술을 대중화시킨 대표적인 도구입니다. 표준화된 형식(Dockerfile)을 통해 이미지를 생성하고, 이를 실행 가능한 컨테이너로 구동하는 기능을 제공합니다. 컨테이너 이미지 저장소로는 Docker Hub, Amazon ECR, Google Artifact Registry 등 다양한 레지스트리가 존재하여 여러 구성 요소와의 연계가 용이합니다.

하지만 다수의 컨테이너를 동시에 운영하고 자동화된 방법으로 배포, 확장, 복구를 진행하려면 더욱 복잡한 컨트롤 플레인이 필요합니다. 이 지점에서 Kubernetes가 등장하게 됩니다.

### Kubernetes의 개념과 핵심 역할

Kubernetes는 컨테이너화된 애플리케이션의 배포, 스케일링, 운영을 자동화하는 오픈 소스 컨테이너 오케스트레이션 플랫폼입니다. 원래 Google에서 internally 운영하던 Borg 시스템을 기반으로 하여, CNCF(Cloud Native Computing Foundation)에 기부되었고 현재는 데브옵스 및 클라우드 네이티브 환경에서 사실상 표준 플랫폼으로 사용됩니다.

#### Kubernetes가 해결하는 과제

- 수백 또는 수천 개의 컨테이너를 클러스터 환경에서 자동으로 배치 및 관리할 수 있도록 함
- 장애가 발생한 컨테이너를 탐지하고 자동으로 재시작하거나 대체 컨테이너를 배포
- 트래픽에 따라 수평적으로 Pod의 수를 자동 조절하여 확장성 확보
- 선언적 인프라 구조: 사용자가 원하는 상태를 정의하면 Kubernetes가 이를 유지하도록 지속적으로 조정합니다.

#### Kubernetes의 핵심 구성 요소

1. Node (노드)

   Kubernetes 클러스터를 구성하는 주체로, 실제 컨테이너가 실행되는 물리적 머신 혹은 가상 머신입니다. 노드는 크게 두 종류로 구분됩니다.

   - Master Node: 클러스터 전체를 제어하는 역할을 수행(스케줄링, 상태 모니터링, 트래픽 분산 등)
   - Worker Node: 실제 컨테이너가 구동되는 실행 환경

2. Pod

   컨테이너의 최소 실행 단위로, 하나 이상의 컨테이너가 함께 실행되며 IP, 볼륨 등을 공유합니다. 일반적으로는 기능단위 마이크로서비스 하나를 하나의 Pod로 구현합니다.

3. Deployment

   Pod의 복제본을 지정된 수로 유지하는 선언적 객체입니다. 사용자의 지정 상태(desired state)에 따라 Kubernetes는 sured state와 actual state를 일치시키기 위해 자동조치를 취합니다.

4. Service

   Pod는 유한 수명과 함께 실행되므로 고정된 IP를 갖지 않습니다. Service는 이들 Pod에 대해 고정된 접근점을 제공하며, 로드 밸런싱 역할도 수행합니다.

5. ConfigMap 및 Secret

   Pod의 설정값으로 사용되며, 외부 구성 데이터를 코드와 분리하여 관리할 수 있도록 해 줍니다. Secret은 민감한 정보를 암호화된 형태로 저장하며 보안 측면에서 중요한 역할을 합니다.

6. Horizontal Pod Autoscaler (HPA)

   모니터링 지표(CPU 사용량 등)를 기준으로 Pod의 수를 수평(scale-out/in)으로 자동 조절합니다.

### Kubernetes를 활용한 마이크로서비스 운영 전략

클라우드 네이티브 애플리케이션은 마이크로서비스 기반으로 구성되는 경우가 많습니다. 각 마이크로서비스는 독립적으로 배포, 확장, 복구되어야 하기 때문에 Kubernetes의 분산 관리 능력은 이상적인 운영 환경을 제공합니다.

예를 들어, 사용자 인증 서비스(auth service), 상품 조회 서비스(product service), 결제 서비스(payment service) 등이 각각 독립된 Pod로 배포되어 있고, 각 서비스는 Deployment 객체로 관리되며, 외부에서는 Service를 통해 접근될 수 있도록 구성합니다. 트래픽이 증가하면 HPA가 Pod 수를 자동으로 확장하고, 특정 Pod가 오류 상태에 빠지면 Kubernetes는 해당 Pod를 삭제하고 다시 띄워서 정상 가용성을 유지합니다.

### 클라우드 환경에서 Kubernetes의 적용 사례

최근 대부분의 주요 클라우드 서비스 제공자는 Kubernetes 관리형 서비스를 제공합니다. 대표적인 서비스로는 다음과 같습니다.

- AWS EKS (Elastic Kubernetes Service)
- Google Kubernetes Engine (GKE)
- Azure Kubernetes Service (AKS)

이러한 관리형 Kubernetes 서비스는 노드 인프라 구성, 컨트롤 플레인 유지보수, 보안 패치, 인증/인가 통합 등을 클라우드 공급자가 대신 관리해주기 때문에 사용자는 비교적 손쉽게 Kubernetes 기반의 애플리케이션을 운용할 수 있습니다.

예컨대, e커머스 기업 A사는 AWS EKS를 통해 주문 처리용 마이크로서비스를 구성했습니다. 각 microservice는 독립적인 CI/CD 파이프라인을 통해 ECR 레지스트리에 빌드된 이미지를 등록하고, 이를 바탕으로 EKS 클러스터에 배포됩니다. 주문 물량이 급증할 경우 주문처리 서비스만 HPA에 의해 확장되고, 시스템상 문제가 발생하면 Kubernetes는 자동으로 복구를 시도합니다. 이로 인해 안정성, 가용성, 운영 효율성이 크게 개선되었습니다.

### 결론

컨테이너와 Kubernetes는 클라우드 네이티브 시대에서 애플리케이션의 설계, 배포, 운영 방식에 혁신을 불러온 핵심 요소입니다. 컨테이너는 가볍고 재현 가능한 실행환경을 제공함으로써 애플리케이션의 이식성과 일관성을 보장하며, Kubernetes는 그 수많은 컨테이너를 클러스터 환경에서 효율적으로 orchestration 할 수 있도록 돕습니다.

현대의 많은 조직이 빠르게 변화하는 운영 환경, 급격한 사용자 증가, 지속적인 기능 업데이트 요구에 효율적으로 대응하기 위해 Kubernetes 기반 아키텍처로의 전환을 선택하고 있습니다. 본 절에서 다룬 개념이 클라우드 네이티브 애플리케이션의 기반 기술로서 여러분의 시스템 설계와 운영에 실질적인 이해를 제공하는 데 도움이 되었기를 바랍니다.