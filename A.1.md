# Stateless 설계 패턴 실전 사례

## 실전 사례 1: 웹 애플리케이션 서버 (예: Nginx + Node.js + Express)

### 아키텍처 요약

* 클라이언트 요청 → 로드밸런서 (예: ALB) → 여러 웹 서버 중 하나로 라우팅
* 각 웹 서버는 사용자 세션 상태를 **서버 내에 저장하지 않음**
* 인증 상태는 JWT(JSON Web Token)를 사용하거나, Redis와 같은 외부 세션 저장소를 활용

### Stateless 설계 포인트

* 서버는 모든 요청을 독립적으로 처리 (세션 정보 없음)
* 서버 간 요청 이동(예: A 서버 → B 서버)이 자유롭고 문제없음
* 확장(Scale-out) 및 축소(Scale-in)에 유리

---

## 실전 사례 2: AWS Lambda 같은 FaaS(Function as a Service)

### 아키텍처 요약

* 요청마다 새로운 함수 인스턴스가 생성되며 실행됨
* 함수 인스턴스는 요청을 처리한 후 바로 종료됨

### Stateless 설계 포인트

* 함수는 이전 상태나 컨텍스트에 의존하지 않음
* 모든 상태(예: 사용자 데이터, 캐시 등)는 외부에 저장 (예: S3, DynamoDB)
* 완전한 무상태 설계를 전제로 동작

---

## 실전 사례 3: Kubernetes 기반 마이크로서비스

### 아키텍처 요약

* 각 서비스는 컨테이너 기반으로 실행되며, POD 간 상태 공유 없음
* 사용자 상태는 Redis, DB, 혹은 외부 메시지 큐에 저장

### Stateless 설계 포인트

* POD가 재시작되거나 다른 노드로 이동해도 서비스 일관성 유지
* 상태 동기화나 복구 과정 없이 바로 재배포 가능

---

## 실전 사례 4: CI/CD 파이프라인 (예: GitHub Actions, GitLab CI)

### 아키텍처 요약

* 각 빌드/테스트 작업은 컨테이너 또는 임시 VM에서 실행
* 작업 결과나 캐시는 외부 아티팩트 저장소(S3, GCS 등)에 저장

### Stateless 설계 포인트

* 빌드 환경은 매번 새롭게 초기화됨
* 외부 저장소와 API를 통해 필요한 모든 정보를 재구성

---

## 실전 사례 5: API Gateway + Backend 서비스

### 아키텍처 요약

* API Gateway는 인증 처리(JWT 등) 후 요청을 백엔드 서비스로 전달
* 백엔드 서비스는 Stateless 방식으로 동작하며, 상태 정보는 DB나 캐시 서버에 저장

### Stateless 설계 포인트

* API 요청 처리 시 사용자 인증 정보는 토큰을 통해 검증
* 서버 재시작이나 다중 인스턴스 운영에 영향 없음

---

## Stateless 설계를 위한 공통 기술 요소

| 목적           | 사용 예시                                     |
| ------------ | ----------------------------------------- |
| 사용자 인증 상태 저장 | JWT, OAuth 토큰                             |
| 세션/임시 상태 관리  | Redis, Memcached                          |
| 영구 상태 저장     | RDB (PostgreSQL, MySQL), NoSQL (DynamoDB) |
| 이벤트 기반 처리    | Kafka, SQS, Pub/Sub                       |
| 파일/오브젝트 저장   | Amazon S3, Azure Blob Storage             |

---

## 요약: 왜 Stateless가 중요한가?

| 장점                | 설명                                    |
| ----------------- | ------------------------------------- |
| 수평 확장 용이          | 서버 수 증가 시에도 상태 공유 문제 없음               |
| 장애 복구 및 재시작 유리    | 상태 손실 걱정 없이 재시작 가능                    |
| CI/CD 자동화에 적합     | 빠르고 예측 가능한 배포 구조 가능                   |
| 클라우드 네이티브 아키텍처 구현 | Auto Scaling, Self-healing 구조와 시너지 발휘 |
